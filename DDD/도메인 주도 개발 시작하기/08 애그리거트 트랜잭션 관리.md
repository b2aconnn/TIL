# 애그리거트와 트랜잭션

애그리거트를 조회하고 트랜잭션을 커밋할 때 수정된 내용을 DB에 저장하게 되는데, 두 스레드가 동시에 트랜잭션 커밋을 하게 되면 애그리거트의 일관성이 깨질 수 있다.

<br>

**일관성이 깨지는 문제를 해결할 수 있는 방법**

- 스레드 A가 조회하고 상태를 변경하는 동안, 스레드 B가 애그리거트를 수정하지 못하게 막는다.
- 스레드 A가 조회한 이후 스레드 B가 정보를 변경하면, 스레드 A가 애그리거트를 다시 조회한 후 수정하도록 한다.

<br>

💁‍♂️ **애그리거트를 위한 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금의 두 가지 방식이 있다.**

<br>

# 선점 잠금

**선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.**

- 스레드 A가 선점 잠금 방식으로 애그리거트를 조회하게 되면, 스레드 B는 스레드 A가 잠금을 해제할 때까지 블로킹 처리가 된다.

- 선점 잠금 방식으로 데이터 충돌 문제를 해소할 수 있다.

<br>

**스프링 데이터 JPA의 @Lock을 활용한 잠금 모드 지정**

~~~java
public interface MemberRepository extends Repository<Member, MemberId> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
}
~~~

<br>

## 선점 잠금과 교착 상태

❗️ **선점 잠금 방식은 데이터 충돌 문제를 해소할 수 있지만, 교착 상태가 발생할 수 있는 문제가 생길 수 있다.**

<br>

**상황**

1. 스레드 1 : A 애그리거트에 대한 선점 잠금 구함
2. 스레드 2 : B 애그리거트에 대한 선점 잠금 구함
3. 스레드 1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드 3: A 애그리거트에 대한 선점 잠금 시도

<br>

위와 같은 순서로 선점 잠금을 구하거나 시도할 경우, 스레드 1은 B 애그리거트에 대한 선점 잠금을 영원히 구할 수 없다.

이와 같이 스레드 1과 스레드 2는 교착 상태에 빠지게 된다.

<br>

🤔 **위와 같은 문제는 어떻게 해결할 수 있을까?**

- **잠금을 구할 때 최대 대기 시간을 지정하게 되면 교착 상태에 대한 문제를 해소할 수 있다.**

<br>

**스프링 데이터 JPA의 @QueryHints를 사용한 잠금을 구하는 대기 시간 지정**

~~~java
public interface MemberRepository extends Repository<Member, MemberId> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints({
            @QueryHint(name = "javax.persistence.lock.timeout", value = "2000")
    })
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
}
~~~

> DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르다. 선점 잠금을 사용하려면 DBMS에 대해 JPA가 어떤 식으로 대기 시간을 처리하는 지 확인해야 한다.

<br>

# 비선점 잠금

🤔 **선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되진 않는다.**

<br>

**예시 상황**

- 운영자는 배송을 위해 주문 정보를 조회한다. 시스템은 정보를 제공한다.
- 고객이 배송지 변경을 위해 변경 폼을 요청한다. 시스템은 변경 폼을 제공한다.
- 고객이 새로운 배송지를 입력하고 폼을 전송하여 배송지를 변경한다.
- 운영자가 1번에서 조회한 주문 정보를 기준으로 배송지를 정하고 배송 상태 변경을 요청한다.

<br>

**문제**

- 운영자가 배송지 정보를 조회 후 배송 상태로 변경하는 사이 고객이 배송지 정보를 변경할 수 있다.
- 고객이 배송지를 변경하면 배송 상태 변경 전에 배송지를 한 번 더 확인하지 않을 결우, 운영자는 다른 배송지로 물건을 발송할 수 있다.
- 이 문제는 선점 잠금 방식으로는 해결할 수 없다.

<br>

💡 **해결 방법**

**애그리거트에 버전 프로퍼티를 추가하여 이 문제를 해결할 수 있다.**

- 애그리거트를 수정할 때마다 버전을 1씩 증가 시킨다.
- 수정할 애그리거트와 매핑되는 테이블의 버전 값이 현재 애그리거트의 버전과 동일한 경우 수정 가능하게 만든다.

<br>

**JPA의 @Version을 활용한 비선점 잠금 기능**

~~~java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;
    
    @Version
    private long version;
    
    // ...
}
~~~

- JPA는 엔티티가 변경되어 UPDATE 쿼리를 실행할 때 @Version에 명시한 필드를 이용해 비선점 잠금 쿼리를 실행한다.
- UPDATE 쿼리를 실행할 때 버전이 일치하는 경우에만 데이터를 수정한다.

~~~sql
UPDATE purchase_order SET version = version + 1 WHERE number = ? AND version = 10
~~~

<br>

**응용 서비스에서 트랜잭션 처리와 표현 영역에서의 예외 처리**

~~~java
public class ChangeShippingService {
    @Transactional
    public void changeShipping(ChangeShippingRequest changeReq) {
        Order order = orderRepository.findById(new OrderNo(changeReq.getNumber()));
        checkNoOrder(order);
        order.changeShippingInfo(changeReq.getShippingInfo());
    }
}


@Controller
public class OrderController {
    private ChangeShippingService changeShippingService;
    
    @PostMapping("/change-shipping")
    public String changeShipping(ChangeShippingRequest changeReq) {
        try {
            changeShippingService.changeShipping(changeReq);
            return "changeShippingSuccess";
        } catch (OptimisticLockingFailureException ex) {
            // 누군가 먼저 같은 주문 애그리거트를 수정했을 때 발생하는 예외
            return "changeShippingTxConflict";
        }
    }
}
~~~

- changeShipping() 메서드가 리턴될 때 트랜잭션이 종료되고, 이 시점에 트랜잭션 충돌이 발생하면 OptimisticLockingFailureException이 발생한다.
- 예외가 발생했다는 건 다른 사용자가 먼저 상태를 변경해 version이 올라간 상태를 의미하고, 쿼리 실행 결과로 수정된 행의 개수가 0개를 의미한다.

<br>

## 강제 버전 증가

JPA는 연관된 엔티티의 값이 변경된다고 해도 루트 엔티티 자체의 값은 바뀌는 것이 없으므로 루트 엔티티의 버전 값을 갱신하지 않는다.

❗️ **위와 같은 경우 애그리거트 관점에서 보면 문제가 된다.**

- 애그리거트의 구성요소의 일부 값이 바뀌면 논리적으로 애그리거트는 바뀐 것이다.
- 구성 요소의 상태가 변경되었을 때 루트 애그리거트의 버전 값이 증가해야 비선점 잠금이 올바르게 동작한다.

<br>

**JPA에서 제공하는 비선점 강제 버전 증가 잠금 모드**

~~~java
@Repository
public class JpaOrderRepository implements OrderRepository {
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public Order findByIdOptimisticLockMode(OrderNo id) {
        return entityManager.find(Order.class, id, LockModelType.OPTIMISTIC_FORCE_INCREMENT);
    }
}
~~~

해당 엔티티의 상태가 변경되었는지에 상관 없이 트랜잭션 종료 시점에 버전 값 증가 처리를 한다.

<br>

