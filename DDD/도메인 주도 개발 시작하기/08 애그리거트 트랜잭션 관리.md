# 애그리거트와 트랜잭션

애그리거트를 조회하고 트랜잭션을 커밋할 때 수정된 내용을 DB에 저장하게 되는데, 두 스레드가 동시에 트랜잭션 커밋을 하게 되면 애그리거트의 일관성이 깨질 수 있다.

<br>

**일관성이 깨지는 문제를 해결할 수 있는 방법**

- 스레드 A가 조회하고 상태를 변경하는 동안, 스레드 B가 애그리거트를 수정하지 못하게 막는다.
- 스레드 A가 조회한 이후 스레드 B가 정보를 변경하면, 스레드 A가 애그리거트를 다시 조회한 후 수정하도록 한다.

<br>

💁‍♂️ **애그리거트를 위한 트랜잭션 처리 방식에는 선점 잠금과 비선점 잠금의 두 가지 방식이 있다.**

<br>

# 선점 잠금

**선점 잠금은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.**

- 스레드 A가 선점 잠금 방식으로 애그리거트를 조회하게 되면, 스레드 B는 스레드 A가 잠금을 해제할 때까지 블로킹 처리가 된다.

- 선점 잠금 방식으로 데이터 충돌 문제를 해소할 수 있다.

<br>

**스프링 데이터 JPA의 @Lock을 활용한 잠금 모드 지정**

~~~java
public interface MemberRepository extends Repository<Member, MemberId> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
}
~~~

<br>

## 선점 잠금과 교착 상태

❗️ **선점 잠금 방식은 데이터 충돌 문제를 해소할 수 있지만, 교착 상태가 발생할 수 있는 문제가 생길 수 있다.**

1. 스레드 1 : A 애그리거트에 대한 선점 잠금 구함
2. 스레드 2 : B 애그리거트에 대한 선점 잠금 구함
3. 스레드 1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드 3: A 애그리거트에 대한 선점 잠금 시도

위와 같은 순서로 선점 잠금을 구하거나 시도할 경우, 스레드 1은 B 애그리거트에 대한 선점 잠금을 영원히 구할 수 없다.

이와 같이 스레드 1과 스레드 2는 교착 상태에 빠지게 된다.

<br>

🤔 **위와 같은 문제는 어떻게 해결할 수 있을까?**

- **잠금을 구할 때 최대 대기 시간을 지정하게 되면 교착 상태에 대한 문제를 해소할 수 있다.**

<br>

**스프링 데이터 JPA의 @QueryHints를 사용한 잠금을 구하는 대기 시간 지정**

~~~java
public interface MemberRepository extends Repository<Member, MemberId> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @QueryHints({
            @QueryHint(name = "javax.persistence.lock.timeout", value = "2000")
    })
    @Query("select m from Member m where m.id = :id")
    Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
}
~~~

> DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르다. 선점 잠금을 사용하려면 DBMS에 대해 JPA가 어떤 식으로 대기 시간을 처리하는 지 확인해야 한다.

<br>

# 비선점 잠금

