# JPA를 이용한 리포지토리 구현

리포지토리 인터페이스는 애그리거트와 같은 도메인 영역에 속하고, 리포지토리를 구현한 클래스는 인프라스트럭처 영역에 속한다.

<p align="center"><img width="700" alt="스크린샷 2023-06-25 오후 11 07 06" src="https://github.com/b2aconnn/TIL/assets/89119477/0d9c4110-d6a8-4e1f-93b3-af7db648231c"></p>

<p align="center">DIP 적용할 경우 구현 클래스는 인프라스트럭쳐 영역에 위치</p>

<br>

## 리포지토리 기본 기능 구현

- ID를 통한 애그리거트 조회
- 애그리거트 저장

<br>

**두 기능을 인터페이스로 표현**

~~~java
public interface OrderRepository {
    Order findById(OrderNo no);
    void save(Order order);
}
~~~

인터페이스는 애그리거트 루트 기준으로 작성을 한다. 

애그리거트를 조회하는 기능의 이름을 지을 때는 보통 findBy프로퍼티이름(프로퍼티 값) 형식으로 사용한다.

<br>

**위의 인터페이스를 JPA의 EntityManager로 구현한 클래스**

~~~java
@Repository
class JpaOrderRepository implements OrderRepository {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public Order findById(OrderNo id) {
        // Id를 통해 애그리거트를 조회
        return entityManager.find(Order.class, id);
    }

    @Override
    public void save(Order order) {
        // 애그리거트를 저장
        entityManager.persist(order);
    }
}
~~~

<br>

**애그리거트의 수정**

~~~java
public class ChangeOrderService {
    @Transactional
    public void changeShippingInfo(OrderNo no, ShippingInfo newShippingInfo) {
        Optional<Order> orderOpt = orderRepository.findById(no);
        Order order = orderOpt.orElseThrow(() -> new OrderNotFoundException());
        // 애그리거트 수정
        order.changeShippingInfo(newShippingInfo);
    }
}
~~~

**애그리거트를 수정한 후에 저장소에 반영하는 메소드를 따로 호출할 필요가 없다.**

JPA를 사용하면 트랙잭션 범위에서 변경한 데이터를 자동으로 UPDATE 쿼리를 실행하여 DB에 반영을 해주기 때문이다.

<br>

**애그리거트 조회**

~~~java
public interface OrderRepository {
    List<Order> findByOrdererId(String ordererId, int startRow, int size);
}
~~~

JPA에서 애그리거트를 조회할 때는 findBy뒤에 조건 대상이 되는 프로퍼티명을 붙이면 된다.

또 JPA의 Criteria나 JPQL, queryDSL 등으로 애그리거트를 조회할 수 있다.

<br>

**애그리거트 삭제**

~~~java
public interface OrderRepository {
    public void delete(Order order);
}
~~~

삭제할 애그리거트를 파라미터로 전달하면 된다.

❗️보통은 실제로 물리적으로 데이터를 삭제(hardDelete)하지 않는다. 데이터 원복이나 일정 기간 동안 데이터를 보관해야 할 때도 있기 때문에 보통은 논리적인 삭제(softDelete)를 통해 관리를 한다.

<br>

# 매핑 구현

## 엔티티와 밸류 기본 매핑 구현

**애그리거트와 JPA 매핑을 위한 기본 규칙**

- 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정

**한 테이블에 엔티티와 밸류가 같이 있다면?**

- 밸류는 @Embeddable로 매핑 설정
- 밸류 타입 프로퍼티는 @Embedded로 매핑 설정

<br>

👉 주문 애그리거트의 예

- 루트 엔티티 : Order
- 밸류 : Orderer, ShippingInfo, Address, Receiver

<p align="center"><img width="700" alt="스크린샷 2023-07-10 오후 11 54 43" src="https://github.com/b2aconnn/TIL/assets/89119477/1e7c3455-ca80-4181-84cc-81a18a84b22e"></p>

<br>

### JPA와 매핑

루트 엔티티인 Order는 JPA의 @Entity로 매핑

~~~java
@Entity
@Table(name = "purchase_order")
public class Order {
    // ...
}
~~~

<br>

Order에 속하는 Orderer는 밸류이므로 @Embeddable로 매핑

~~~java
@Embeddable
public class Orderer {
    // MemberId에 정의된 컬럼 이름을 변경하기 위해 @AttributeOverride 사용
    @Embedded
    @AttributeOverrides(
        @AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
    )
    private MemberId memberId;

    @Column(name = "orderer_name")
    private String name;
}

@Embeddable
public class MemberId implements Serializable {
    @Column(name = "member_id")
    private String id;
}
~~~

<br>

루트 엔티티 Order 클래스는 @Embedded를 선언해 밸류 타입 프로퍼티를 설정

~~~java
@Entity
public class Order {
    @Embedded
    private Orderer orderer;
    @Embedded
    private ShippingInfo shippingInfo;
}
~~~

<br>

## 기본 생성자

**Receiver는 밸류이고, 불변 타입으로 만들려면 생성 시점에 필요한 값들을 생성자를 통해 모두 전달 받으므로 set 메서드를 제공하지 않는다. 즉, 기본 생성자는 필요 없다는 것을 의미**한다.

<br>

❗️하지만 JPA에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자가 필요함

- DB에서 데이터를 읽어와서 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문

<br>

이런 기술적인 제약으로 인해 Receiver와 같은 불변 탕비은 기본 생성자가 필요 없음에도 기본 생성자를 추가해야 한다. 😢

~~~java
@Embeddable
public class Receiver {
    @Column(name = "receiver_name")
    private String name;
    @Column(name = "receiver_phone")
    private String phone;

    protected Receiver() {} // JPA를 적용하기 위한 기본 생성자 추가

    public Receiver(String name, String phone) {
        this.name = name;
        this.phone = phone;
    }
}
~~~

**기본 생성자는 JPA Provider가 객체를 생성할 때만 사용하기 때문에 다른 코드에서는 기본 생성자를 사용하지 못하도록 protected 접근 제한자를 통해 제한한다.**

<br>

## 필드 접근 방식 사용

JPA는 필드와 메서드 두 가지 방식으로 매핑을 처리할 수 있다.

- 메서드 방식 : 프로퍼티를 위한 get/set 메서드를 구현

~~~java
@Entity
@Access(AccessType.PROPERTY)
public class Order {
    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    public OrderState getState() {
        return state;
    }
    
    public setState(OrderState state) {
        this.state = state;
    }
}
~~~

❗️ 위와 같이 메서드 방식을 통해 프로퍼티를 위한 set 메서드를 만들게 되면 내부 데이터를 외부에서 변경할 수 있는 가능성을 열어두기 때문에 캡슐화를 깨는 원인이 되어 객체로서 제 역할을 하지 못 할 수 있다.

<br>

- 필드 방식

~~~java
@Entity
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    private OrderState state;
    
    public void cancel() { // 명확한 의도로 도메인 기능 구현
        // ...
    }
}
~~~

set 메서드 대신 명확한 의도가 드러나는 기능을 제공하므로써 도메인을 더 잘 표현할 수 있다.

<br>

## AttributeConverter를 이용한 밸류 매핑 처리

Integer, String LocalDateTime과 같은 타입은 DB 테이블의 한 개의 컬럼에 매핑되어서 저장이 가능하다.

밸류 타입의 프로퍼티를 한 개 컬럼에 매핑해야 할 때에는 @Embeddable로 처리할 수 없다.

<p align="center"><img width="600" alt="스크린샷 2023-07-12 오후 9 16 00" src="https://github.com/b2aconnn/TIL/assets/89119477/c2f83622-d96f-4390-891f-88b2e9470a15"></p>

👉 **밸류 타입의 두 개 이상의 프로퍼티를 한 개의 컬럼으로 매핑하는 방법으로 AttributeConverter가 있다.**

~~~java
public interface AttributeConverter<X, Y> { // X: 밸류 타입, Y: DB 타입
    public Y convertToDatabaseColumn(X attribute); // 밸류 타입 -> DB 컬럼 값으로 변환
    public X convertToEntityAttribute(Y dbData); // DB 컬럼 값 -> 밸류 타입 값으로 변환
}
~~~

<br>

**Money 밸류 타입을 위한 AttributeConverter 구현**

~~~java
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> {
    @Override
    public Integer convertToDatabaseColumn(Money money) {
        return money == null ? null : money.getValue();
    }
    
    @Override
    public Money convertToEntityAttribute(Integer value) {
        return value == null ? null : new Money(value);
    }
}
~~~

- AttributeConverter의 구현 클래스는 @Converter 적용해야 함
- autoApply 속성의 값으로 true를 지정하면 Money 타입의 프로퍼티에 대해 MoneyConverter를 자동으로 적용

<br>

**MoneyConverter가 적용된 Order Entity**

~~~java
@Entity
@Table(name = "purchase_order")
public class Order {
    // ...
    
    @Column(name = "total_amounts")
    private Money totalAmounts; // MoneyConverter를 적용해서 값 변환
}
~~~

<br>

**autoApply = false일 경우 직접 컨버터 지정**

~~~java
public class Order {
    @Column(name = "total_amounts")
    @Convert(converter = MoneyConverter.class)
    private Money totalAmounts;
}
~~~

<br>

## 밸류 컬렉션: 별도 테이블 매핑

Order Entity는 한 개 이상의 OrderLine을 가질 수 있다.

<br>

**순서를 가지는 OrderLine을 포함한 Order Entity**

~~~java
public class Order {
    private List<OrderLine> orderLines;
    // ...
}
~~~

<br>

밸류 컬렉션인 **`List<OrderLine>`** 을 별도 테이블로 매핑할 때는 **`@ElementCollection`** 과 **`@CollectionTable`**을 함께 사용

~~~java
@Entity
@Table(name = "purchase_order")
public class Order {
    @EmbeddedId
    private OrderNo number;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "order_line",
               joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;
    
    // ...
}

@Embeddable
public class OrderLine {
    @Embedded
    private ProductId productId;
    
    @Column(name = "price")
    private Money price;
    
    @Column(name = "quantity")
    private int quantity;
    
    @Column(name = "amounts")
    private Money amounts;
}
~~~

- @OrderColumn : 지정한 컬럼에 리스트의 인덱스 값을 저장
  - line_idx라는 DB 컬럼에 인덱스가 저장됨
- @CollectionTable : 밸류를 저장할 테이블을 지정
  - name 속성 : 테이블 이름 지정
  - joinColumns 속성 : 외부키로 사용할 컬럼 지정

<br>

## 밸류 컬렉션: 한개 컬럼 매핑

밸류 컬렉션을 별도 테이블이 아닌 **한 개 컬럼에 저장해야 할 때 AttributeConverter를 사용하여 매핑할 수 있다.**

AttributeConverter를 사용하려면 밸류 컬렉션을 표현하는 밸류 타입을 하나 추가해야 한다.

<br>

**Email 주소 목록의 밸류 타입 클래스**

~~~java
public class EmailSet {
    private Set<Email> emails = new HashSet<>(); // 밸류 컬렉션

    public EmailSet(Set<Email> emails) {
        this.emails.addAll(emails);
    }

    public Set<Email> getEmails() {
        return Collections.unmodifiableSet(emails);
    }
}
~~~

<br>

**AttributeConverter 구현**

~~~java
public class EmailSetConverter implements AttributeConverter<EmailSet, String> {
    @Override
    public String convertToDatabaseColumn(EmailSet attribute) {
        // ...
    }

    @Override
    public EmailSet convertToEntityAttribute(String dbData) {
        // ...
    }
}
~~~

<br>

**Converter 지정**

~~~java
@Column(name = "emails")
@Convert(converter = EmailSetConverter.class)
private EmailSet emailSet;
~~~

<br>

## 밸류를 이용한 ID 매핑

밸류 타입을 식별자로 매핑하려면 @Id가 아닌 @EmbeddedId를 사용해야 한다.

~~~java
@Embeddable
public class OrderNo implements Serializable {
    @Column(name = "order_number")
    private String number;
    
    public boolean is2ndGeneration() {
        return number.startsWith("N");
    }
}
~~~

💁‍♂️ **밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점이다.**

- 1세대 시스템 주문 번호와 2세대 시스템의 주문 번호를 구분할 때 첫 글자를 이용할 경우, is2ndGeneration() 메서드를 사용해서 기능을 구현할 수 있다.

👉 JPA는 내부적으로 엔티티를 비교할 목적으로 equals()와 hashcode() 값을 사용하므로 식별자로 밸류 타입을 사용할 경우 두 메서드를 알맞게 구현해야 한다.

<br>

## 별도 테이블에 저장하는 밸류 매핑

애그리거트에서 루트 엔티티를 제외한 구성요소는 대부분 밸류이다.

<br>

💁‍♂️ **밸류인 지 엔티티인 지 구분하는 방법은 고유 식별자를 갖는 지의 여부에 따라 구분할 수 있다.**

- 별도 테이블에 데이터를 저장한다고 해서 엔티티인 것은 아니다.
- 식별자를 찾을 때 매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각해선 안된다.
  - 별도 테이블로 저장하고 테이블에 PK가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 항상 고유 식별자를 갖는 것은 아니기 때문

<br>

<p align="center"><img width="500" alt="스크린샷 2023-07-14 오전 12 13 31" src="https://github.com/b2aconnn/TIL/assets/89119477/354ab74d-d82f-4120-bbc7-f4a29da6e7eb"></p>

<p align="center">밸류를 엔티티로 잘못 매핑한 예</p>

<br>

ARTICLE 테이블과 ARTICLE_CONTENT 테이블의 1:1 관계이다. 

ARTICLE_CONTENT 테이블에 있는 **ID 값이 식별자 역할도 가능은 하지만 ARTICLE 테이블과 연관관계를 갖기 위함이기 때문에 엔티티로  판단하기보단 밸류로 판단하는 것이 더 올바른 설계일 수 있다.**

그렇기 때문에 게시글의 특정 프로퍼티를 별도 테이블에 보관하는 것으로 접근해야 한다.

<br>

<p align="center"><img width="500" alt="스크린샷 2023-07-14 오전 12 26 48" src="https://github.com/b2aconnn/TIL/assets/89119477/8ab4ae89-9c62-4a62-b95c-2b0ed3e92b82"></p>

<p align="center">별도 테이블로 밸류를 매핑한 모델</p>

<br>

**@SecondaryTable을 이용한 밸류 매핑 설정**

~~~java
@Entity
@Table(name ="atricle")
@SecondaryTable(
        name = "article_content",
        pkJoinColumns = @PrimaryKeyJoinColumn(name = "id")
)
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    @AttributeOverrides({
            @AttributeOverride(
                    name = "content",
                    column = @Column(table = "article_content", name = "content")),
            @AttributeOverride(
                    name = "contentType",
                    column = @Column(table = "article_content", name = "content_type"))
    })
    @Embedded
    private ArticleContent content;
}
~~~

- ArticleContent는 밸류이므로 @Embeedable로 매핑

- @SecondaryTable, @AttributeOverride : 밸류를 매핑한 테이블을 지정

  - @SecondaryTable

    - name 속성 : 밸류를 저장할 테이블을 지정

    - pkJoinColumns 속성 : 밸류 테이블에서 엔티티 테이블로 조인할 때 사용할 컬럼 지정

<br>

👉 **@SecondaryTable을 이용하면 Article 엔티티를 조회할 때 ArticleContent도 같이 조회된다.**

~~~java
@SecondaryTable로 매핑된 article_content 테이블을 조인
Article article = entityManager.find(Article.class, 1L);
~~~

- article 테이블의 데이터만 필요할 때 불필요하게 article_content 테이블의 데이터까지 조회된다.

지연 로딩 방식을 설정해서 문제를 해결할 수 있지만 하지만 밸류 모델을 엔티티로 만들어야 하기 때문에 좋은 방법은 아니다. 😢

<br>

💡 **위와 같은 문제를 해결하기 위해 지연 로딩 대신 조회 전용 기능을 구현하는 방법을 사용하는 것이 좋다.**

<br>

