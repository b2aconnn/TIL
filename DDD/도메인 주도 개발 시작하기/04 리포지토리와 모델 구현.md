# JPA를 이용한 리포지토리 구현

리포지토리 인터페이스는 애그리거트와 같은 도메인 영역에 속하고, 리포지토리를 구현한 클래스는 인프라스트럭처 영역에 속한다.

<p align="center"><img width="700" alt="스크린샷 2023-06-25 오후 11 07 06" src="https://github.com/b2aconnn/TIL/assets/89119477/0d9c4110-d6a8-4e1f-93b3-af7db648231c"></p>

<p align="center">DIP 적용할 경우 구현 클래스는 인프라스트럭쳐 영역에 위치</p>

<br>

## 리포지토리 기본 기능 구현

- ID를 통한 애그리거트 조회
- 애그리거트 저장

<br>

**두 기능을 인터페이스로 표현**

~~~java
public interface OrderRepository {
    Order findById(OrderNo no);
    void save(Order order);
}
~~~

인터페이스는 애그리거트 루트 기준으로 작성을 한다. 

애그리거트를 조회하는 기능의 이름을 지을 때는 보통 findBy프로퍼티이름(프로퍼티 값) 형식으로 사용한다.

<br>

**위의 인터페이스를 JPA의 EntityManager로 구현한 클래스**

~~~java
@Repository
class JpaOrderRepository implements OrderRepository {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public Order findById(OrderNo id) {
        // Id를 통해 애그리거트를 조회
        return entityManager.find(Order.class, id);
    }

    @Override
    public void save(Order order) {
        // 애그리거트를 저장
        entityManager.persist(order);
    }
}
~~~

<br>

**애그리거트의 수정**

~~~java
public class ChangeOrderService {
    @Transactional
    public void changeShippingInfo(OrderNo no, ShippingInfo newShippingInfo) {
        Optional<Order> orderOpt = orderRepository.findById(no);
        Order order = orderOpt.orElseThrow(() -> new OrderNotFoundException());
        // 애그리거트 수정
        order.changeShippingInfo(newShippingInfo);
    }
}
~~~

**애그리거트를 수정한 후에 저장소에 반영하는 메소드를 따로 호출할 필요가 없다.**

JPA를 사용하면 트랙잭션 범위에서 변경한 데이터를 자동으로 UPDATE 쿼리를 실행하여 DB에 반영을 해주기 때문이다.

<br>

**애그리거트 조회**

~~~java
public interface OrderRepository {
    List<Order> findByOrdererId(String ordererId, int startRow, int size);
}
~~~

JPA에서 애그리거트를 조회할 때는 findBy뒤에 조건 대상이 되는 프로퍼티명을 붙이면 된다.

또 JPA의 Criteria나 JPQL, queryDSL 등으로 애그리거트를 조회할 수 있다.

<br>

**애그리거트 삭제**

~~~java
public interface OrderRepository {
    public void delete(Order order);
}
~~~

삭제할 애그리거트를 파라미터로 전달하면 된다.

❗️보통은 실제로 물리적으로 데이터를 삭제(hardDelete)하지 않는다. 데이터 원복이나 일정 기간 동안 데이터를 보관해야 할 때도 있기 때문에 보통은 논리적인 삭제(softDelete)를 통해 관리를 한다.

<br>

# 매핑 구현

## 엔티티와 밸류 기본 매핑 구현

**애그리거트와 JPA 매핑을 위한 기본 규칙**

- 애그리거트 루트는 엔티티이므로 @Entity로 매핑 설정

**한 테이블에 엔티티와 밸류가 같이 있다면?**

- 밸류는 @Embeddable로 매핑 설정
- 밸류 타입 프로퍼티는 @Embedded로 매핑 설정

<br>

👉 주문 애그리거트의 예

- 루트 엔티티 : Order
- 밸류 : Orderer, ShippingInfo, Address, Receiver

<p align="center"><img width="700" alt="스크린샷 2023-07-10 오후 11 54 43" src="https://github.com/b2aconnn/TIL/assets/89119477/1e7c3455-ca80-4181-84cc-81a18a84b22e"></p>

<br>

### JPA와 매핑

루트 엔티티인 Order는 JPA의 @Entity로 매핑

~~~java
@Entity
@Table(name = "purchase_order")
public class Order {
    // ...
}
~~~

<br>

Order에 속하는 Orderer는 밸류이므로 @Embeddable로 매핑

~~~java
@Embeddable
public class Orderer {
    // MemberId에 정의된 컬럼 이름을 변경하기 위해 @AttributeOverride 사용
    @Embedded
    @AttributeOverrides(
        @AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
    )
    private MemberId memberId;

    @Column(name = "orderer_name")
    private String name;
}

@Embeddable
public class MemberId implements Serializable {
    @Column(name = "member_id")
    private String id;
}
~~~

<br>

루트 엔티티 Order 클래스는 @Embedded를 선언해 밸류 타입 프로퍼티를 설정

~~~java
@Entity
public class Order {
    @Embedded
    private Orderer orderer;
    @Embedded
    private ShippingInfo shippingInfo;
}
~~~

<br>

## 기본 생성자

**Receiver는 밸류이고, 불변 타입으로 만들려면 생성 시점에 필요한 값들을 생성자를 통해 모두 전달 받으므로 set 메서드를 제공하지 않는다. 즉, 기본 생성자는 필요 없다는 것을 의미**한다.

<br>

❗️하지만 JPA에서 @Entity와 @Embeddable로 클래스를 매핑하려면 기본 생성자가 필요함

- DB에서 데이터를 읽어와서 매핑된 객체를 생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문

<br>

이런 기술적인 제약으로 인해 Receiver와 같은 불변 탕비은 기본 생성자가 필요 없음에도 기본 생성자를 추가해야 한다. 😢

~~~java
@Embeddable
public class Receiver {
    @Column(name = "receiver_name")
    private String name;
    @Column(name = "receiver_phone")
    private String phone;

    protected Receiver() {} // JPA를 적용하기 위한 기본 생성자 추가

    public Receiver(String name, String phone) {
        this.name = name;
        this.phone = phone;
    }
}
~~~

**기본 생성자는 JPA Provider가 객체를 생성할 때만 사용하기 때문에 다른 코드에서는 기본 생성자를 사용하지 못하도록 protected 접근 제한자를 통해 제한한다.**

<br>

## 필드 접근 방식 사용

JPA는 필드와 메서드 두 가지 방식으로 매핑을 처리할 수 있다.

- 메서드 방식 : 프로퍼티를 위한 get/set 메서드를 구현

~~~java
@Entity
@Access(AccessType.PROPERTY)
public class Order {
    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    public OrderState getState() {
        return state;
    }
    
    public setState(OrderState state) {
        this.state = state;
    }
}
~~~

❗️ 위와 같이 메서드 방식을 통해 프로퍼티를 위한 set 메서드를 만들게 되면 내부 데이터를 외부에서 변경할 수 있는 가능성을 열어두기 때문에 캡슐화를 깨는 원인이 되어 객체로서 제 역할을 하지 못 할 수 있다.

<br>

- 필드 방식

~~~java
@Entity
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Column(name = "state")
    @Enumerated(EnumType.STRING)
    private OrderState state;
    
    public void cancel() { // 명확한 의도로 도메인 기능 구현
        // ...
    }
}
~~~

set 메서드 대신 명확한 의도가 드러나는 기능을 제공하므로써 도메인을 더 잘 표현할 수 있다.
