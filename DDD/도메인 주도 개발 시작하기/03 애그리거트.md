# 애그리거트

시스템 개발을 할 때 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 이해를 하는 데 도움이 된다.

<p align="center"><img width="400" alt="스크린샷 2023-06-11 오후 10 33 43" src="https://github.com/b2aconnn/TIL/assets/101120568/74131f60-9b6f-4302-86f6-75fe78195c7d"></p>

<p align="center">상위 수준에서의 모델</p>

도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.

<p align="center"><img width="500" alt="스크린샷 2023-06-11 오후 11 03 02" src="https://github.com/b2aconnn/TIL/assets/101120568/035580ca-8639-4963-8b39-3cced4c90ada"></p>

<p align="center">개별 객체 수준에서의 모델</p>

주요 도메인 요소 간의 관계를 파악하기 어려우면 코드를 변경하고 확장하는 것이 어려워진다.

이 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만드려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요하다.

그 방법이 애그리거트이다.

<br>

👉 **애그리거트로 개별 객체들을 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 좀 더 쉽게 파악할 수 있다.**

- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.
- 애그리거트 단위로 일관성을 관리하기 때문에, 복잡한 도메인을 단순한 구조로 만들어준다.
- 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 비용도 줄어든다.

<img width="500" alt="스크린샷 2023-06-11 오후 11 18 06" src="https://github.com/b2aconnn/TIL/assets/101120568/fcb9454f-dcfe-4ede-8651-9807c8e00642">

👉 **애그리거트는 경계를 갖는다.**

- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않고, 각 애그리거트는 자기 자신을 관리만을 관리할 뿐 다른 애그리거트를 관리하지 않는다.
  - ex. 주문 애그리거트는 배송지 변경을 하거나 주문 상품 개수를 변경하는 등의 자기 자신을 관리하지만, 회원의 정보를 변경하거나 상품의 정보를 변경하지 않는다.
- 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.
  - 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
    - ex. 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성되므로 한 애그리거트에 속한다.
  - 'A가 B를 갖는다'로 설계할 수 있는 요구사항이 있다면, 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미하지는 않는다.
    - ex. 상품과 리뷰는 상품 상제 정보에 함께 보여줘야 하는 요구사항이 있을 수 있지만 상품(Product)와 리뷰(Review)는 함께 생성되거나 변경되지 않는다.

> 도메인 모델을 처음 만들 때는 큰 애그리거트로 보이는 것들이 많을 수 있지만, 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다. 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많은 편이고 두 개 이상의 엔티티로 구성되는 애그리거트는 드물다는 필자님의 말씀이 있다.

<br>

# 애그리거트 루트

도메인 규칙을 지키기 위해 애그리거트에 속한 객체는 하나의 객체만 정상이면 안 되고, 모든 객체가 정상 상태를 가져야 한다.

- ex. OrderLine을 변경하면 Order의 totalAmounts인 총 금액도 같이 변경 되어야 한다.

<br>

👉 **이처럼 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티**이다.

- 루트 엔티티는 애그리거트의 대표 엔티티이다.
- 애그리거트에 속한 객체들은 애그리거트 루트 엔티티에 직간접적으로 속하게 된다.

<img width="300" alt="스크린샷 2023-06-14 오후 11 38 18" src="https://github.com/b2aconnn/TIL/assets/101120568/8ae11e2d-b7d5-47d5-870f-d8c12de36927">

주문 애그리거트에서 루트 엔티티 역할은 Order이다.

<br>

## 도메인 규칙과 일관성

**애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.**

<br>

💁‍♂️ **애그리거트의 일관성을 유지하기**

👉 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.

~~~java
// 애그리거트 루트
public class Order {

    // 도메인 규칙을 구현한 기능
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
    }

    private void verifyNotYetShipped() {
        if (state != OrderState.PAYMENT_WAITING && state != OrderState.PREPARING) {
            throw new IllegalStateException("already shipped");
        }
    }
}
~~~

<br>

👉 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하지 못하게 한다.

~~~java
ShippingInfo shippingInfo = order.getShippingInfo();
shippingInfo.setAddress(newAddress); // setter
~~~

**외부에서 직접 변경의 문제점**

- 속성을 변경할 수 있는 공개된 Setter를 쓰게 되면 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 될 수 있다.
- Setter를 쓰기 전에 검증을 해야 하는 로직이 있을 경우, 매번 중복된 코드로 구현을 해야 한다.
- 도메인 로직이 한 곳에 있지 않기 때문에 응집도가 낮아지고 유지보수에 좋지 않다.
- 만약 검증 로직을 Setter안에 넣는다고 하더라도 SetXXX()이라는 네이밍보다 어떤 책임인 지 의미를 잘 전달할 수 있는 네이밍으로 지어야 코드를 문서화하는데 좋고 유지보수도 하기 좋아진다.

**애그리거트 루트에서의 도메인 로직 구현**

- 단순히 필드를 변경하는 public setter를 만들지 않는다.
- 밸류 타입은 불변으로 구현한다.

<br>

## 애그리거트 루트의 기능 구현

애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
